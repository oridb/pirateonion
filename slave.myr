use std
use sys
use bio
use cryptohash

use "opts.use"

pkg =
	const slave : (dirs : byte[:][:] -> void)
;;

const slave = {dirs
	var filemap

	filemap = std.mkht(std.strhash, std.streq)
	std.put("Running as slave\n")
	for d in dirs
		filelist(filemap, d)
		syncsend(filemap)
	;;

	filemapfree(filemap)
}

const syncsend = {filemap
	var fhash : byte[64]
	var n

	while true
		n = std.try(std.read(0, fhash[:]))
		if n == 64
			sendfile(filemap, fhash[:])
		elif n <= 0
			break
		;;
	;;
}

const sendfile = {filemap, fhash
	var buf : byte[1024*1024]
	var path
	var sz, n
	var fd
	var sb

	match std.htget(filemap, fhash)
	| `std.None:	std.put("Error locating %s\n", fhash)
	| `std.Some p:	path = p
	;;

	fd = std.try(std.open(path, std.Ordonly))
	if sys.fstat((fd : sys.fd), &sb) != 0
		std.put("Erred to stat %s\n", path)
		-> void
	;;
	sz = (sb.size : std.size)
	std.put("%l\n", sz)
	while true
		n = std.try(std.read(fd, buf[:]))
		if n == 0
			break
		elif n < 0
			break
		;;
		n = std.clamp(n, 0, sz)
		std.write(0, buf[:n])
		sz -= n
	;;
}

const filelist = {filemap, path
	var dir
	var sb
	var p

	match std.diropen(path)
	| `std.Ok d:
		dir = d
	| `std.Err m:	
		std.put("Could not open dir %s: %s\n", path, m)
		-> void
	;;
	while true
		match std.dirread(dir)
		| `std.None:		break
		| `std.Some ".": 	continue
		| `std.Some "..":	continue
		| `std.Some ent:
			p = std.pathcat(path, ent)
			if sys.stat(p, &sb) != 0
				std.put("Could not stat file %s\n")
			;;
			if (sb.mode & sys.Sifmt) == sys.Sifdir
				filelist(filemap, p)
			elif (sb.mode & sys.Sifmt) == sys.Sifreg
				filehash(filemap, p)
			else
				std.put("skipping special file: %s\n", p)
			;;
			std.slfree(p)
			std.slfree(ent)
		;;
:skip
	;;
	std.dirclose(dir)
}

const filehash = {filemap, p
	var buf : byte[1024*1024]
	var hbuf : byte[64]
	var hval
	var fd
	var n
	var h

	cryptohash.sha256init(&h)
	fd = std.try(std.open(p, std.Ordonly))

	while true
		n = std.try(std.read(fd, buf[:]))
		if n == 0
			break
		;;
		cryptohash.sha256add(&h, buf[:n])
	;;
	hval = cryptohash.sha256fin(&h)
	std.close(fd)
	n = 0
	for b in hval[:]
		std.bfmt(hbuf[n:], "0%02xb", b)
		n += 2
	;;
	std.put("hash: %s\tpath: %s\n", hbuf[:n], p)
	std.htput(filemap, std.sldup(hbuf[:n]), std.sldup(p))
}

const filemapfree = {fm
	var keys

	keys = std.htkeys(fm)
	for k in keys
		std.slfree(std.htgetv(fm, k, ""))
		std.slfree(k)
	;;
	std.slfree(keys)
	std.htfree(fm)
}
