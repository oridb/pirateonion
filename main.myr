use std
use cryptohash

var opt_client = false
var opt_dirs

const main = {args
	var ctx

	ctx = std.optinit("h", args)
	while !std.optdone(ctx)
		match std.optnext(ctx)
		| ('h', _):	usage(args[0])
		;;
	;;

	opt_dirs = ["."][:]
	/*loadconfig()*/
	if opt_client
		client()
	else
		server()
	;;
}

const client = {
	std.fatal(1, "Unimplemented client\n")
}

const server = {
	std.put("Running as server\n")
	for d in opt_dirs
		std.put("Listing %s\n", d)
		filelist(d)
	;;
}

const filelist = {path
	var dir
	var sb
	var p

	match std.diropen(path)
	| `std.Ok d:	dir = d
			std.put("Opened %s\n", path)
	| `std.Fail m:	std.put("Could not open dir %s: %s\n", path, m)
	;;
	while true
		match std.dirread(dir)
		| `std.None:	break
		| `std.Some ".":	continue
		| `std.Some "..":	continue
		| `std.Some ent:
			std.put("Handling %s within %s\n", ent, path)
			p = pathjoin(path, ent)
			std.put("Path is %s\n", p)
			if std.stat(p, &sb) != 0
				std.put("Could not stat file %s\n")
			else
				std.put("Stat worked\n")
			;;
			std.put("Mode == %xw\n", sb.mode)
			std.put("Mode & Sifmt == %xw\n", sb.mode & std.Sifmt)
			if (sb.mode & std.Sifmt) == std.Sifdir
				std.put("%s is dir\n", p)
				filelist(p)
			elif (sb.mode & std.Sifmt) == std.Sifreg
				std.put("%s is file\n", p)
				filehash(p)
			else
				std.put("Special file: %s\n", p)
			;;
			std.slfree(p)
			std.slfree(ent)
		;;
	;;
	std.put("Done with %s\n", path)
	std.dirclose(dir)
}

const filehash = {p
	var buf : byte[1024*1024]
	var hval
	var fd
	var n
	var h

	cryptohash.sha256init(&h)
	fd = std.open(p, std.Ordonly)
	if fd < 0
		std.put("Could not open %s\n", p)
		->
	;;

	while true
		std.put("Reading\n")
		n = std.read(fd, buf[:])
		std.put("Got %l\n", n)
		if n == 0
			break
		elif n < 0
			std.put("Error reading %s\n", p)
			break
		;;
		std.put("Adding %l bytes of data\n", n)
		cryptohash.sha256add(&h, buf[:n])
		std.put("Done\n")
	;;
	hval = cryptohash.sha256fin(&h)
	std.close(fd)
	std.put("hash: ")
	for b in hval[:]
		if b < 0x10
			std.put("0%xb", b)
		else
			std.put("%xb", b)
		;;
	;;
	std.put("\tpath:%s\n", p)
}

const pathjoin = {a, b
	var sep

	if a[a.len-1] == '/' castto(byte) || b[0] == '/' castto(byte)
		sep = ""
	else
		sep = "/"
	;;

	-> std.fmt("%s%s%s", a, sep, b)
}

const usage = {bin
	std.put("%s [-h]\n")
	std.put("\tPirate onion. Arr-chives your files.\n")
	std.put("\t-h\tprint this help\n")
}
